# STARTER
## Challenge 1:
This challenge asks us to use the python built in function pow(base,exponent,modulus) to compute the value of 101<sup>17</sup> mod 22663  
so we use the following code snippet:

    print(pow(101,17,22663))
so we get the answer as:
>19906

## challenge 2:
This challenge is just to encrypt the number  12 using rsa algorithm
for which the base is 65537 and modulo is 17*23  
so we used the following script:

    print(pow(12,65537,17*23))
so we get the encrypted number 
> 301

## Challenge 3:
Now the task is to find out the totient of the large number N we can understand totient as something that represents no.of coprimes of the number below it. for a number of having only two prime numbers as factors i.e. p,q 

phi(N) = (p-1)(q-1)



so, for p = 857504083339712752489993810777, q = 1029224947942998075080348647219 then totient is:
>882564595536224140639625987657529300394956519977044270821168

## Challenge 4:
first consider writing gcd(e,N) in extended gcd form and let it be, ex + Ny = gcd(e,N) e being prime we have gcd(e,N)=1 so we write  
ex = gcd(e,N) - Ny
ex = 1 - Ny
applying mod N on both sides.  
e*x mod N = 1  
clearly x is the modular inverse  
code:
```
def extended_gcd(a, b):
    if a == 0:
        return 0, 1
    x1, y1 = extended_gcd(b % a, a)
    x = y1 - (b // a) * x1
    y = x1
    return x, y

def mod_inverse(a, m):
    x, y = extended_gcd(a, m)
    return x % m

p = 857504083339712752489993810777
q = 1029224947942998075080348647219
e = 65537

N = p * q

phi_N = (p - 1) * (q - 1)
d = mod_inverse(e, phi_N)

print(f"The private key d is: {d}")
```
The value of the key is:
>121832886702415731577073962957377780195510499965398469843281

## Challenge 5:
Now we have to decrypt the message  
c = encrypted message  
d = private key  
N = phi(product of numbers)  


we decrypt the message by  
c<sup>d</sup>mod N  
with the code:
```
print(pow(77578995801157823671636298847186723593814843845525223303932,d,N))
```
where d,N are from previous question and we get the number:
>13371337

## Challenge 6:
given the key
```
N = 15216583654836731327639981224133918855895948374072384050848479908982286890731769486609085918857664046075375253168955058743185664390273058074450390236774324903305663479046566232967297765731625328029814055635316002591227570271271445226094919864475407884459980489638001092788574811554149774028950310695112688723853763743238753349782508121985338746755237819373178699343135091783992299561827389745132880022259873387524273298850340648779897909381979714026837172003953221052431217940632552930880000919436507245150726543040714721553361063311954285289857582079880295199632757829525723874753306371990452491305564061051059885803
d = 11175901210643014262548222473449533091378848269490518850474399681690547281665059317155831692300453197335735728459259392366823302405685389586883670043744683993709123180805154631088513521456979317628012721881537154107239389466063136007337120599915456659758559300673444689263854921332185562706707573660658164991098457874495054854491474065039621922972671588299315846306069845169959451250821044417886630346229021305410340100401530146135418806544340908355106582089082980533651095594192031411679866134256418292249592135441145384466261279428795408721990564658703903787956958168449841491667690491585550160457893350536334242689

```
given,  
H=crypto{Immut4ble_m3ssag1ng}
Here we are using libraries like Crypto,hashlib The script of the following question is as follow:  
```
import hashlib
import Crypto.Util.number as num

# Given values
N = 15216583654836731327639981224133918855895948374072384050848479908982286890731769486609085918857664046075375253168955058743185664390273058074450390236774324903305663479046566232967297765731625328029814055635316002591227570271271445226094919864475407884459980489638001092788574811554149774028950310695112688723853763743238753349782508121985338746755237819373178699343135091783992299561827389745132880022259873387524273298850340648779897909381979714026837172003953221052431217940632552930880000919436507245150726543040714721553361063311954285289857582079880295199632757829525723874753306371990452491305564061051059885803
d = 11175901210643014262548222473449533091378848269490518850474399681690547281665059317155831692300453197335735728459259392366823302405685389586883670043744683993709123180805154631088513521456979317628012721881537154107239389466063136007337120599915456659758559300673444689263854921332185562706707573660658164991098457874495054854491474065039621922972671588299315846306069845169959451250821044417886630346229021305410340100401530146135418806544340908355106582089082980533651095594192031411679866134256418292249592135441145384466261279428795408721990564658703903787956958168449841491667690491585550160457893350536334242689
H = 'crypto{Immut4ble_m3ssag1ng}'
H = H.encode()

# Compute SHA-256 hash of the message
hash = hashlib.sha256(H).digest()

# Convert the hash into a number
message = num.bytes_to_long(hash)

print(pow(message,d,N))
```

the sign of the message is
```
13480738404590090803339831649238454376183189744970683129909766078877706583282422686710545217275797376709672358894231550335007974983458408620258478729775647818876610072903021235573923300070103666940534047644900475773318682585772698155617451477448441198150710420818995347235921111812068656782998168064960965451719491072569057636701190429760047193261886092862024118487826452766513533860734724124228305158914225250488399673645732882077575252662461860972889771112594906884441454355959482925283992539925713424132009768721389828848907099772040836383856524605008942907083490383109757406940540866978237471686296661685839083475
```
# Public Exponent
## Salty:
Here we two files one is the encryption code:
```
#!/usr/bin/env python3

from Crypto.Util.number import getPrime, inverse, bytes_to_long, long_to_bytes

e = 1
d = -1

while d == -1:
    p = getPrime(512)
    q = getPrime(512)
    phi = (p - 1) * (q - 1)
    d = inverse(e, phi)

n = p * q

flag = b"XXXXXXXXXXXXXXXXXXXXXXX"
pt = bytes_to_long(flag)
ct = pow(pt, e, n)

print(f"n = {n}")
print(f"e = {e}")
print(f"ct = {ct}")

pt = pow(ct, d, n)
decrypted = long_to_bytes(pt)
assert decrypted == flag
```
the exponent being one and ct is much less than n then we won't observe any change to the ct even after encryption and in output.txt we have
```
n = 110581795715958566206600392161360212579669637391437097703685154237017351570464767725324182051199901920318211290404777259728923614917211291562555864753005179326101890427669819834642007924406862482343614488768256951616086287044725034412802176312273081322195866046098595306261781788276570920467840172004530873767                                                                  
e = 1
ct = 44981230718212183604274785925793145442655465025264554046028251311164494127485
```
here the ct remains unchanged so it is as simple as converting the long into bytes and get the flag.
so the script here is:
```
from Crypto import Util
ct = 44981230718212183604274785925793145442655465025264554046028251311164494127485
print(long_to_bytes(ct))
```
now we get the flag as:
>crypto{saltstack_fell_for_this!}